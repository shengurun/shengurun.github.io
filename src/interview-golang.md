# Go 语言相关

## Array 和 Slice

- **数组**和**切片**的区别有哪些？

    数组和切片都是一组同类型的数据的集合。  
    数组是一个值类型，在初始化时便已经固定了长度和容量，无法变更。
    切片则是一个引用类型，在初始化时有声明长度和容量。当使用 `append()` 追加数据，使其长度将大于容量时，切片则会进行扩容，将其容量变为原来的**2 倍**。但是当原切片长度大于或等于 `1024`，则扩容时容量变为原来的**1.25 倍**。

- 切片在使用内建函数 `append()` 追加数据时，如果超出定义的容量，是会进行扩容的。由于扩容后的新切片不一定拥有新的地址，因此通常采用 `a = append(a, T)` 的形式。但如果使用 `append()` 追加数据时，切片并未扩容，是否需要该形式才会追加数据到该切片？

    需要的。  
    简单来说，切片是基于数组实现，切片创建时会生成一个长度为对应容量的数组，可使用 `append()` 追加数据。由于切片除了存有长度和容量外，还有指向数组的位置，在使用 `append()` 时虽然追加了数据到指向的数组，修改了长度（也可能同时修改了容量），但是原切片存有的数组始末指向并未变更，所以还会是截取原先的那一段数据。

## 内建函数 make() 与 Map

- 内建函数 `make()` 和 `new()` 有什么区别？

    `make()` 只能用于创建及初始化 slice、map、channel 这三种对象，这三种对象的内存空间和初始结构均已生成。返回的是参数对应的复合类型。如 `make([]int, 0)` 是等价于 `[]int{}` 的。（不等于 `nil`）  
    `new()` 用于创建任意数据类型，返回的是**指针**对象。创建时分配了内存空间，但是若是复合类型，并不会初始化内部结构。如 `*new([]int)` 等价于 `[]int(nil)`、（等于 `nil`） `newMap := *(new(map[string]int))` 是没法对 `newMap` 赋予键值对的。  
    顺带一提，`T{}` 也是实现了也是实现了创建及初始化的，所以常代替 `new()` 出现在各种场合。

- 使用 `T{}` 创建一个 `map`，和使用 `make()` 函数来创建一个 `map`，有什么区别？

    没有区别。`z := make(map[int]string)` 是等价于 `z := map[int]string{}` 的。

- 对于一个创建的 `map` 对象，一边使用 `for`-`range` 进行遍历，一边在循环体中使用内建函数 `delete()` 删除 `map` 内的数据，会有什么影响？

    如果是多协程执行的情况下，是会有数据竞争问题的。  
    但如果是单一协程的场景下，基本是没有问题的。官方文档中也有案例 [Effective Go](https://golang.org/doc/effective_go#for)。

- 自定义一个结构体 `AStruct`，对一个存有数据的 `map[string]AStruct`进行 key 遍历，并在循环体中对使用 `map[key]` 获取到的结构体进行字段修改，会产生效果吗？

    不会。编译器是无法通过该代码的。  
    如果需要修改 `map` 内部的结构体数据，可以使用 `map[string]*AStruct` 来进行遍历处理，抑或将整个 value 的 AStruct 结构体进行替换。

- Map 是如何扩容的？

- 为什么 GC 无法回收 Map？

    该问题比较存疑。题目是“得物”的一个技术发问的，说是 Golang 的 GC 是无法回收 Map 的。

    但是我在网上检索到的结果，大都是说 GC 回收 Map 效率低，还没查询到解释无法回收的答案。

## Channel

- `channel` 的实现原理是怎样的？

- 向一个被内建函数 `close()` 关闭的 `channel` 中接收数据会发生什么？发送数据的话又会发生什么？
  
    向一个已经关闭的 channel 中接收数据，如果是有缓冲区、且缓冲区内有数据的 channel，按接受次数依次遍历缓冲区内数据，当缓冲区内数据遍历完后，返回的是 channel 类型的默认零值。如果是没有缓冲区，则每次接收都是 channel 类型的默认零值。  
    发送数据则会抛出 `panic: send to closed channel` 异常。

- 如果再次使用内建函数 `close()` 操作一个已经关闭的 `channel`，会发生什么？

    会抛出 `panic: close of closed channel` 异常。

## Struct

- 什么是**空结构体**？

    空结构体类型是 `struct{}`，实例化的对象时 `struct{}{}`。它并不占用内存，内存中的地址不会改变。常用于 `map[string]struct{}` 来创建集合（`set`）对象，或者 `chan struct{}` 来进行通信但不传递有效数据。

- Golang 中使用首字母大写来实现 Public 对象，首字母小写则是 Private 对象，那使用标准库中的 `json` 包来处理一个*首字母大写*、但是内部字段全是*小写字母*的 `struct`，是否可以正确处理？

    不可以。  
    Golang 使用首字母大小写来判断数据是 Public 还是 Private，但是结构体字段也同样适用。`json` 包对当前编写的包来说是属于外部包的，所以是无法访问 Private 数据的。

## Interface

- 什么是 `interface`？
- 若一个函数的参数类型为一个定义过的 `interface`，当实现了该 `interface` 的结构体作为参数传入该函数，函数是否能知道该对象为何结构体？

    编译时无法知晓，只有在运行时才能知道。

## defer() 和 panic()

- 于函数内声明一个 `defer()`，它会在何时执行？

    `return` 最先给返回值赋值；然后 `defer()` 开始执行收尾工作；最后 `RET` 指令携带返回值推出函数。所以 `defer()` 可以对 `return` 进行干涉。  
    顺带一提，若声明了多个 `defer()` 则会如同 `出栈` 一样，最后的 `defer()` 先执行，逐步向上。

- `panic()` 和 `defer()` 调用的先后顺序是怎样的？

    `panic()` 是先被触发执行，其内会调用 `gopanic()` 函数来执行 `defer()`。（只会执行已经入 `栈` 的 `defer()`，定义在 `panic()` 后的 `defer()` 是不会被执行到的）。但是 `panic()` 的信息则是最后才展现出来。  
    顺带一提，`panic()` 触发之后，`defer()` 函数再次触发了新的 `panic()`，则前一个 panic 停止执行，进行当前的 panic。  

- 什么是 `recover()` 函数？

    `recover()` 是一个内建函数，其只有定义在 `defer()` 函数中才会发挥用途。当 panic 发生，`recover()` 会不会到 panic 的值，并将当前 goroutine 恢复正常运行。  
    `panic()` 发生后，会执行完当前协程已经压入 `栈` 中的所有 `defer()`，如没有 `recover()` 的调用，则会直接退出**进程**。是进程不是协程，所以不会触发其他协程的 `defer()`，且不会传递给父函数。

## Goroutine/协程

- 什么是 **Goroutine**?

- 如何控制协程数量？

## 编译器相关

- 如何理解 Golang 的**内存逃逸**？

    如果变量的内存发生逃逸，那么它会被分配到 `堆` 上，堆内存不会如同栈内存一样自动释放，而是依赖于 GC 机制。  
    常见的内存逃逸情况有：  
    1. 函数内把其局部变量指针使用 `return` 返回，被外部使用。
    2. 在 `interface` 类型上调用方法，因为 `interface` 调用方法是动态调度，只有在运行时才知道。
    3. 发送指针或者带有指针的值到 channel 中，因为只有运行后才会知道哪个 goroutine 接收了数据。
    4. 切片的扩容以及切片存储指针数据。

- Golang 编译器的 GC 算法是怎样的？

    三色标记法。

- 什么是 GMP 模型？

    GMP 是一种**线程**模型，基于 `M:N` 的多对多线程模型构建。`M` 对应的是系统线程，`P` 代表的是一个抽象出来的处理器概念，`G` 则是 goroutine。  
    `P` 会携带一批 `G` 任务，然后将其交给 `M` 来执行。如果当前 `P` 的 `G` 清空了，则会从其他 `P` 中窃取任务来交给当前 `M`。如果当前 `M` 阻塞了，`P` 会把接下来的 `G` 交给其他 `M`。  
    `P` 的数量使用 `runtime.GOMAXPROCS()` 函数决定的，`M` 的数量则是由 `runtime.SetMaxThreads()` 所决定。

- 什么是 CSP 模型？

    CSP 是一种**并发**模型，全称是 `通信顺序进程`，描述了独立的并发实体通过共享通讯来继续通信。  
    在 Golang 中，CSP 模型则是使用 channel 来实现共享通讯。  
    当然，Golang 依旧可以使用**共享内存**并发模型，案例便是锁（sync.Lock）的使用。

## Go 工具集相关

- `go mod` 一般使用流程是怎样的？
- `go mod tidy` 做了什么事？
